<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>AWS on GoniGoni!</title>
    <link>/categories/aws/</link>
    <description>Recent content in AWS on GoniGoni!</description>
    <generator>Hugo</generator>
    <language>ko-kr</language>
    <lastBuildDate>Sun, 09 Jun 2024 12:40:00 +0900</lastBuildDate>
    <atom:link href="/categories/aws/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Amazon Q로 간단한 API 만들어 보기 (with Go)</title>
      <link>/posts/create-api-with-amazon-q/</link>
      <pubDate>Sun, 09 Jun 2024 12:40:00 +0900</pubDate>
      <guid>/posts/create-api-with-amazon-q/</guid>
      <description>&lt;h2 id=&#34;배경&#34;&gt;배경&lt;/h2&gt;&#xA;&lt;p&gt;인프라를 관리하다 보면, 수동으로 하는 일을 자동화 할 수 있는 방법을 고민할 것입니다. 그래서 인프라 구성을 코드로 관리하기도 하고, 간단한 스크립트나 프로그램을 만들기도 합니다. 그 중에서도 &amp;ldquo;스크립트로 제공하는 것들을 API로 만들어 보면 어떨까?&amp;rdquo; 라는 생각을 했는데요. DevOps나 SRE 분야에서 사용하는 도구들이 Go(Golang)으로 만든 경우가 많아서 Go를 선택하였습니다. 찾아 보니 Go를 이용한 웹 프레임워크로는 Gin과 같은 것들이 있더라구요. 이를 활용해서 간단한 API를 만들어 보려고 합니다. (에디터로는 Visual Studio Code를 이용합니다)&lt;/p&gt;</description>
    </item>
    <item>
      <title>AWS Certified Solutions Architect - Professional 시험 후기</title>
      <link>/posts/aws-sap-c01/</link>
      <pubDate>Wed, 11 May 2022 23:14:04 +0900</pubDate>
      <guid>/posts/aws-sap-c01/</guid>
      <description>&lt;h2 id=&#34;계기&#34;&gt;계기&lt;/h2&gt;&#xA;&lt;p&gt;저는 2년 전에 AWS의 &lt;a href=&#34;https://www.credly.com/earner/earned/badge/c6d39aca-7679-40ad-ab01-163b5334d75d&#34;&gt;Certified Solutions Architect - Associate&lt;/a&gt; 자격증을 취득한 적이 있습니다. 언젠가는 다음 단계의 자격증을 취득할 생각이 있긴 했습니다. (다음 자격증 시험에 응시할 때 50% 할인 쿠폰이 크긴 하더라구요)&lt;/p&gt;&#xA;&lt;p&gt;그러다가 작년 하반기에 이직을 하였고, 최근 몇 개월 동안 현재 시스템을 분석하고 개선하는 작업들을 진행했습니다. 저희 팀은 지금의 시스템을 운영하고, 다음 버전의 시스템을 구축하여야 하는 과제가 있는데요. 그 과정에서 시스템을 구축하고 운영하는 데 좀 더 많은 지식이 필요하겠다는 생각이 들었습니다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>AWS Session Manager &amp; Run Command로 외부에서 쉘 스크립트 실행하기</title>
      <link>/posts/aws-session-manager-run-command/</link>
      <pubDate>Thu, 30 Sep 2021 14:38:05 +0900</pubDate>
      <guid>/posts/aws-session-manager-run-command/</guid>
      <description>&lt;p&gt;AWS의 Systems Manager에는 &lt;a href=&#34;https://aws.amazon.com/ko/blogs/aws/new-ec2-run-command-remote-instance-management-at-scale/&#34;&gt;Run Command&lt;/a&gt;와 &lt;a href=&#34;https://aws.amazon.com/ko/blogs/korea/new-session-manager/&#34;&gt;Session Manager&lt;/a&gt;라는 기능이 있습니다.&lt;/p&gt;&#xA;&lt;p&gt;SSH를 이용하여 EC2 인스턴스에 접근할 때는 SSH 키 페어가 필요하고, SSH 접속을 위한 보안 그룹을 열어야 하는데요. 위 기능을 이용하면 이러한 과정을 생략하고 원격에서 EC2 인스턴스에 접근하여 명령을 실행할 수 있습니다.&lt;/p&gt;&#xA;&lt;p&gt;먼저, Session Manager로 웹 브라우저에서 쉘을 실행하는 방법부터 설명드리겠습니다.&lt;/p&gt;&#xA;&lt;h1 id=&#34;session-manager로-웹-브라우저에서-쉘-실행하기&#34;&gt;Session Manager로 웹 브라우저에서 쉘 실행하기&lt;/h1&gt;&#xA;&lt;p&gt;Session Manager로 웹 브라우저에서 쉘을 실행하려면, EC2 인스턴스가 Systems Manager와 관련된 작업을 실행할 수 있는 권한을 부여해야 합니다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>CloudFormation과 SAM을 쓰면서 겪었던 일들 모음</title>
      <link>/posts/cloudformation-sam-tmi/</link>
      <pubDate>Sat, 28 Aug 2021 15:51:33 +0900</pubDate>
      <guid>/posts/cloudformation-sam-tmi/</guid>
      <description>&lt;p&gt;최근 인프라 구성을 CloudFormation을 이용해서 조정해 보았습니다. 그 과정에서 여러 Lambda 함수를 쓸 때는 SAM으로, 그 외의 경우는 CloudFormation을 사용했는데요.&lt;/p&gt;&#xA;&lt;p&gt;이번 작업으로 여러 CloudFormation 스택에 흩어져 있던 리소스를 하나로 모으고, 템플릿의 관리 방식도 좀 더 관리하게 편하도록 설정할 수 있게 되었습니다.&lt;/p&gt;&#xA;&lt;p&gt;저희 팀이 여러 IaC(Infrastructure as Code) 툴 중에 왜 SAM과 CloudFormation을 사용하는 이유는 &lt;a href=&#34;/posts/retrospect-aws-sam/&#34;&gt;이 문서&lt;/a&gt;를 참고해 주세요.&lt;/p&gt;&#xA;&lt;p&gt;이번 글은 CloudFormation과 SAM을 쓰면서 겪었던 일들을 정리해 보려고 합니다.&lt;/p&gt;&#xA;&lt;h2 id=&#34;sam에서-api-gateway-정의를-sam-template에-넣기&#34;&gt;SAM에서 API Gateway 정의를 SAM Template에 넣기&lt;/h2&gt;&#xA;&lt;p&gt;SAM에서 제공하는 &lt;code&gt;AWS::Serverless::Api&lt;/code&gt; 리소스는 AWS Gateway의 REST API를 생성해 주는 기능입니다. API Gateway에는 &lt;a href=&#34;https://docs.aws.amazon.com/ko_kr/apigateway/latest/developerguide/api-gateway-import-api.html&#34;&gt;OpenAPI 규격으로 작성된 API 스펙을 가지고 올 수 있는 기능&lt;/a&gt;이 있는데요. SAM에서도 마찬가지로 해당 기능을 지원합니다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>EKS 내 NGINX Ingress에서 NLB와 ACM 연동 방법 살펴보기</title>
      <link>/posts/eks-nlb-acm-test/</link>
      <pubDate>Sat, 31 Jul 2021 20:08:14 +0900</pubDate>
      <guid>/posts/eks-nlb-acm-test/</guid>
      <description>&lt;p&gt;최근 팀 내에서 외부 서비스와 연동하는 서비스가 증가하면서, 고정된 IP 주소를 요청하는 경우가 많아졌습니다.&lt;/p&gt;&#xA;&lt;p&gt;한편, 대외 서비스가 늘어나다 보니 관리하는 서버의 수가 증가하였습니다. 그렇지만 생각보다 트래픽이 많지 않아 리소스가 낭비되는 경우가 많은데요.&lt;/p&gt;&#xA;&lt;p&gt;이러한 상황을 겪으면서 서버의 수를 줄이고, 서비스마다 고정된 IP 주소를 제공할 방법을 찾아보게 되었습니다.&lt;/p&gt;&#xA;&lt;p&gt;그러다가 Kubernetes와 Kubernetes의 Ingress를 적절히 활용하여 이러한 요건을 충족하는 방법을 찾아보았습니다.&lt;/p&gt;&#xA;&lt;p&gt;이번 글은 그 과정에서 겪었던 이슈를 정리하기 위해 작성하였습니다.&lt;/p&gt;&#xA;&lt;h1 id=&#34;eks와-nginx-ingress-controller-사용&#34;&gt;EKS와 NGINX Ingress Controller 사용&lt;/h1&gt;&#xA;&lt;p&gt;저희 팀의 웹 서비스들은 Elastic Beanstalk를 주로 이용하고 있습니다. 그렇지만 사용량이 생각했던 것보다는 많지 않아서 컨테이너를 기반으로 한 서비스로 변경해 보려고 합니다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Boto3를 쓰면서 겪었던 일들 모음</title>
      <link>/posts/boto3-note/</link>
      <pubDate>Mon, 28 Jun 2021 22:34:04 +0900</pubDate>
      <guid>/posts/boto3-note/</guid>
      <description>&lt;p&gt;Python을 이용해서 AWS의 여러 기능을 자동화 할 때 Boto3를 많이들 쓰실 것 같은데요. 이번 달에는 Boto3를 쓰면서 궁금했던 것, 또는 자주 사용할 만한 것들을 정리해 보려고 합니다.&lt;/p&gt;&#xA;&lt;h1 id=&#34;현재-사용-중인-aws-계정-id-얻기&#34;&gt;현재 사용 중인 AWS 계정 ID 얻기&lt;/h1&gt;&#xA;&lt;p&gt;여기서 계정 ID라고 하면, 12자리의 숫자로 구성된 계정의 ID를 의미합니다.&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; boto3&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;account_id &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; boto3&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;client(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;sts&amp;#39;&lt;/span&gt;)&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;get_caller_identity()&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;get(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;Account&amp;#39;&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;출처: &lt;a href=&#34;https://stackoverflow.com/questions/33332050/getting-the-current-user-account-id-in-boto3&#34;&gt;Stack Overflow&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h1 id=&#34;에러-다루기&#34;&gt;에러 다루기&lt;/h1&gt;&#xA;&lt;p&gt;출처: &lt;a href=&#34;https://boto3.amazonaws.com/v1/documentation/api/latest/guide/error-handling.html&#34;&gt;Boto3 Documentation&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/boto/boto3/blob/develop/boto3/exceptions.py&#34;&gt;Boto3의 코드&lt;/a&gt;를 열어보면, 서비스에 따라 발생할 수 있는 모든 에러를 저장하고 있지 않습니다. Boto3와 AWS CLI의 기반이 되는 &lt;a href=&#34;https://github.com/boto/botocore/blob/develop/botocore/exceptions.py&#34;&gt;Botocore 프로젝트의 코드&lt;/a&gt;에서도 모든 종류의 예외를 다루지 않습니다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>AWS SAM에서 중첩된 스택 배포 시 유의해야 할 것들</title>
      <link>/posts/aws-sam-nested-stack/</link>
      <pubDate>Mon, 29 Jun 2020 20:58:17 +0900</pubDate>
      <guid>/posts/aws-sam-nested-stack/</guid>
      <description>&lt;p&gt;팀에서 AWS SAM을 적극적으로 사용하고 있는데, SAM을 쓰면서 느낀 점들을 예전에 &lt;a href=&#34;/posts/retrospect-aws-sam/&#34;&gt;글로 남긴 적이 있었다&lt;/a&gt;. 그런데 SAM은 CloudFormation 스택으로 리소스를 생성하다 보니, CloudFormation의 제약 사항을 그대로 가지고 있다. 예를 들어 &lt;a href=&#34;https://docs.aws.amazon.com/ko_kr/AWSCloudFormation/latest/UserGuide/cloudformation-limits.html&#34;&gt;하나의 CloudFormation 템플릿에서 선언할 수 있는 리소스 수는 200개를 넘지 않아야 한다&lt;/a&gt;는 것이 대표적일 것이다. 이러한 문제를 겪으면서, 많은 리소스로 구성되어 있는 애플리케이션을 여러 스택으로 나누는 작업을 해야 했다. 이 글에서는 하나의 서버리스 애플리케이션을 여러 스택으로 나누는 문제를 해결하면서 겪었던 일들을 기록해 보려고 한다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>AWS Lambda에 Pandas 올리기</title>
      <link>/posts/pandas-on-aws-lambda/</link>
      <pubDate>Sat, 27 Jun 2020 21:45:40 +0900</pubDate>
      <guid>/posts/pandas-on-aws-lambda/</guid>
      <description>&lt;p&gt;팀 내에서는 Lambda 안에 파이썬 코드를 올려서 쓰고 있지만, 혹시 Pandas와 같은 라이브러리를 Lambda에 올리려면 어떻게 해야 할 지 궁금해서 정리해 본다.&lt;/p&gt;&#xA;&lt;p&gt;이 예제에서는 Pandas를 Lambda Layer로 만들고, Layer를 Lambda 함수에 연결해서 사용해 보려고 한다.&lt;/p&gt;&#xA;&lt;h2 id=&#34;aws-lambdalambda-layer의-제한&#34;&gt;AWS Lambda(Lambda Layer)의 제한&lt;/h2&gt;&#xA;&lt;p&gt;AWS Lambda에는 Lambda Layer라고 해서 의존성이 필요한 것들을 묶어서 별도의 계층으로 만들어 쓸 수 있도록 하고 있다.&lt;/p&gt;&#xA;&lt;p&gt;하지만 이런 기능도 제한이 있으니 한 번 확인해 보자.&lt;/p&gt;&#xA;&lt;h3 id=&#34;참고-문서&#34;&gt;참고 문서&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://docs.aws.amazon.com/ko_kr/lambda/latest/dg/gettingstarted-limits.html&#34;&gt;AWS Lambda 제한&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://docs.aws.amazon.com/ko_kr/lambda/latest/dg/configuration-layers.html&#34;&gt;AWS Lambda 계층&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;주요-제한-사항&#34;&gt;주요 제한 사항&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;하나의 함수에서 사용할 수 있는 Layer 수: 5 개&lt;/li&gt;&#xA;&lt;li&gt;함수와 Layer를 모두 합하여 250 MB를 초과할 수 없음&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;pandas-lambda-layer-만들기&#34;&gt;Pandas Lambda Layer 만들기&lt;/h2&gt;&#xA;&lt;p&gt;Lambda Layer의 내용은 &lt;code&gt;/opt&lt;/code&gt; 디렉터리에 들어가게 된다. 파이썬 코드의 경우 &lt;code&gt;/opt/python&lt;/code&gt;이나 &lt;code&gt;/opt/python/lib/python(버전-예:3.8)/site-packages&lt;/code&gt; 디렉터리에 풀릴 것이다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>AWS SAM을 사용하면서 느꼈던 것들</title>
      <link>/posts/retrospect-aws-sam/</link>
      <pubDate>Tue, 22 Oct 2019 21:02:00 +0900</pubDate>
      <guid>/posts/retrospect-aws-sam/</guid>
      <description>&lt;h2 id=&#34;왜-sam을-사용하게-되었나&#34;&gt;왜 SAM을 사용하게 되었나?&lt;/h2&gt;&#xA;&lt;p&gt;시스템 내부에서 관리하는 Lambda 함수들이 늘어나면서, 이를 관리할 방법을 찾아야 했다. 기존에는 &lt;a href=&#34;https://apex.run&#34;&gt;Apex&lt;/a&gt;를 Lambda 함수 배포에 이용했지만, 뭔가 자동화된 방법을 찾고 싶었다.&lt;/p&gt;&#xA;&lt;p&gt;그래서 Serverless Framework, Terraform, SAM과 같은 도구들을 검토해 봤다. 그러다가 SAM을 최종적으로 선택했는데, 이유는 다음과 같다.&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;Serverless Framework는 다양한 클라우드 벤더를 지원하지만, 다른 AWS 서비스를 연동하는 데 제약이 있지 않을까? 하는 막연한 생각이 들었다. (잘 찾아보니 내가 원하는 것들은 구현 가능할 것 같더라. 내가 잘못 생각했던 것 같다)&lt;/p&gt;</description>
    </item>
    <item>
      <title>Hortonworks Sandbox를 AWS에서 사용하기</title>
      <link>/posts/hortonworks-sandbox-on-aws/</link>
      <pubDate>Wed, 16 Oct 2019 21:05:00 +0900</pubDate>
      <guid>/posts/hortonworks-sandbox-on-aws/</guid>
      <description>&lt;h2 id=&#34;들어가며&#34;&gt;들어가며&lt;/h2&gt;&#xA;&lt;p&gt;최근에 &lt;a href=&#34;http://www.yes24.com/Product/Goods/44307209&#34;&gt;&amp;lsquo;하둡과 스파크를 활용한 실용 데이터 과학&amp;rsquo;&lt;/a&gt;이라는 책을 읽고 따라해 보고 있다. 이 책에서는 실습을 위해 호튼웍스(Hortonworks)의 Sandbox 이미지를 사용해 보기를 권장하고 있다. 그런데 설치 방법을 찾다 보니, 권장 사양이 높은 것 같다는 생각이 들었다. 이 이미지를 VirtualBox에서 사용할 때, 메모리 용량이 8GB로 설정되어 있었다. 그런데 지금 내가 쓰고 있는 노트북의 메모리 용량이 8GB라 좀 어려울 것 같았다. 그래서 AWS에 이 이미지를 올려보게 되었다.&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;(주의: 이 글에서 설명하는 내용은 AWS의 Free Tier 범위를 넘어가므로 사용한 만큼 요금이 부과됩니다. 크레딧이 있거나 비용 지불이 가능한 경우에 사용하시기 바랍니다. 비용 발생에 대한 책임은 독자에게 있습니다.)&lt;/strong&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>EC2에 Bitnami MongoDB 이미지 올리기</title>
      <link>/posts/bitnami-mongodb/</link>
      <pubDate>Sat, 16 Feb 2019 22:30:00 +0900</pubDate>
      <guid>/posts/bitnami-mongodb/</guid>
      <description>&lt;p&gt;최근에 AWS에서 MongoDB와 호환되는 &lt;a href=&#34;https://aws.amazon.com/ko/documentdb/&#34;&gt;DocumentDB&lt;/a&gt;를 출시했지만, &lt;del&gt;아직 서울 리전에서는 사용할 수 없다.&lt;/del&gt;&lt;/p&gt;&#xA;&lt;p&gt;(2019년 5월에 서울 리전에 출시되었습니다. &lt;a href=&#34;https://aws.amazon.com/ko/blogs/korea/amazon-documentdb-and-kinesis-analytics-seoul-region/&#34;&gt;링크한 글을 확인해 주세요~&lt;/a&gt;)&lt;/p&gt;&#xA;&lt;p&gt;그렇지만 필요에 따라 MongoDB를 쓸 일이 있을 것이다. AWS에서 Bitnami의 이미지를 활용해서 EC2에 MongoDB를 올려보고, 시험 삼아 데이터를 넣어보자.&lt;/p&gt;&#xA;&lt;h3 id=&#34;ec2-설정&#34;&gt;EC2 설정&lt;/h3&gt;&#xA;&lt;p&gt;EC2 인스턴스를 생성하기 위해 AWS의 EC2 콘솔로 들어간다. 아래 스크린샷과 같은 화면이 나오면, &amp;lsquo;인스턴스 시작&amp;rsquo;을 누른다.&lt;/p&gt;&#xA;&lt;figure&gt;&lt;img src=&#34;/img/bitnami-mongodb-1.png&#34;&gt;&#xA;&lt;/figure&gt;&#xA;&#xA;&lt;p&gt;그리고 검색어에서 MongoDB를 입력하고, 왼쪽에서 AWS Marketplace를 누른다.&lt;/p&gt;&#xA;&lt;figure&gt;&lt;img src=&#34;/img/bitnami-mongodb-2.png&#34;&gt;&#xA;&lt;/figure&gt;&#xA;&#xA;&lt;p&gt;스크롤을 아래로 내리다 보면, &amp;lsquo;MongoDB Certified by Bitnami&amp;rsquo;가 있다. 오른쪽의 선택 버튼을 누른다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>S3 버킷의 객체가 1,000개를 넘을 때 객체 목록 조회하기</title>
      <link>/posts/list-over-1000-files-from-s3/</link>
      <pubDate>Thu, 29 Nov 2018 00:38:00 +0900</pubDate>
      <guid>/posts/list-over-1000-files-from-s3/</guid>
      <description>&lt;p&gt;S3 버킷에는 여러 파일들을 저장할 수 있다. 그런데, 버킷에 저장된 파일의 목록을 보고 싶은 경우가 있을 것이다. 하지만, AWS의 Python SDK인 Boto3에서 &lt;code&gt;list_objects()&lt;/code&gt;나 &lt;code&gt;list_objects_v2()&lt;/code&gt; 함수를 이용하면 최대 1,000개까지의 object만 가져올 수 있다. &lt;a href=&#34;https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/s3.html#S3.Client.list_objects_v2&#34;&gt;[참고]&lt;/a&gt; (근본적으로는 AWS의 API가 최대 1,000개까지의 object만 가져오도록 구현되어 있다. - &lt;a href=&#34;https://docs.aws.amazon.com/AmazonS3/latest/API/v2-RESTBucketGET.html&#34;&gt;[참고]&lt;/a&gt;)&lt;/p&gt;&#xA;&lt;p&gt;이런 문제를 해결하기 위해, 다음과 같이 Paginator를 이용해 보자.&lt;/p&gt;&#xA;&lt;h3 id=&#34;paginator-이용하기&#34;&gt;Paginator 이용하기&lt;/h3&gt;&#xA;&lt;h4 id=&#34;get_paginator로-paginator-가져오기&#34;&gt;get_paginator()로 Paginator 가져오기&lt;/h4&gt;&#xA;&lt;p&gt;기본적으로 S3를 담당할 클라이언트를 생성한 뒤, get_paginator()로 Paginator를 가져온다. 여기서는 하나의 버킷에서 object들을 가져오기 위해 &lt;code&gt;list_objects_v2&lt;/code&gt;를 이용한다. (Boto3 문서에서는 &lt;code&gt;list_objects()&lt;/code&gt;보다 &lt;code&gt;list_objects_v2()&lt;/code&gt;를 이용하는 것을 권장하니 이를 이용하자.)&lt;/p&gt;</description>
    </item>
    <item>
      <title>Python으로 Step Functions 활동 만들기</title>
      <link>/posts/step-function-with-python/</link>
      <pubDate>Thu, 04 Oct 2018 23:21:00 +0900</pubDate>
      <guid>/posts/step-function-with-python/</guid>
      <description>&lt;p&gt;AWS에는 &lt;a href=&#34;https://aws.amazon.com/ko/step-functions/&#34;&gt;Step Functions&lt;/a&gt;라는 서비스가 있다. 여러 개의 활동(activity)를 조합해서 순서대로 또는 반복적으로 원하는 작업을 실행할 수 있도록 해 주는 서비스이다.&lt;/p&gt;&#xA;&lt;p&gt;일반적으로는 여러 개의 Lambda 함수를 연결해서 사용하는 경우가 많다. 하지만 Lambda 함수의 실행 시간이 5분을 넘어가면, 다른 방법을 고려해야 한다. 이럴 때 활동을 생성하고 이를 수행하는 코드를 작성하면, 오래 걸리는 작업도 Step Functions로 이용할 수 있다.&lt;/p&gt;&#xA;&lt;h2 id=&#34;활동activity-만들기&#34;&gt;활동(Activity) 만들기&lt;/h2&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;Step Functions 콘솔의 왼쪽 메뉴에서 &lt;code&gt;활동&lt;/code&gt;을 클릭한다.&lt;/li&gt;&#xA;&lt;li&gt;화면이 바뀌면 우측의 &lt;code&gt;활동 생성&lt;/code&gt;을 클릭하여 새로운 활동을 만든다.&lt;/li&gt;&#xA;&lt;li&gt;활동 이름 입력 창에서 임의의 활동 이름을 입력한다.&lt;/li&gt;&#xA;&lt;li&gt;여기서 나오는 ARN을 메모한다. 활동 이름은 알고 있어도 되지만 몰라도 상관은 없다.&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;상태-머신state-machine-만들기&#34;&gt;상태 머신(State Machine) 만들기&lt;/h2&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;콘솔의 왼쪽 메뉴에서 &lt;code&gt;상태 머신&lt;/code&gt;을 클릭한다.&lt;/li&gt;&#xA;&lt;li&gt;우측 상단의 &lt;code&gt;상태 머신 생성&lt;/code&gt;을 클릭한다.&lt;/li&gt;&#xA;&lt;li&gt;상태 머신의 이름을 입력하고, 필요한 경우 IAM 역할을 생성한다. &lt;!-- raw HTML omitted --&gt; (&lt;code&gt;나를 위한 역할 생성&lt;/code&gt;에 체크, &lt;code&gt;AWS Step Functions이 Lambda 함수에 대한...&lt;/code&gt; 옵션에 체크)&lt;/li&gt;&#xA;&lt;li&gt;그리고 &lt;code&gt;상태 머신 정의&lt;/code&gt; 칸에는 다음과 같이 입력한다. (여기가 앞에서 메모한 ARN이 사용되는 부분이다. ARN은 뒤에서도 이용하니 메모를 버리지 말자.)&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-json&#34; data-lang=&#34;json&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;StartAt&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;TestActivity&amp;#34;&lt;/span&gt;,&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;States&amp;#34;&lt;/span&gt;: {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;TestActivity&amp;#34;&lt;/span&gt;: {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;Type&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Task&amp;#34;&lt;/span&gt;,&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;Resource&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;앞에서 메모한 ARN 주소&amp;#34;&lt;/span&gt;,&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;End&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;간단하게 설명을 하자면,&lt;/p&gt;</description>
    </item>
    <item>
      <title>RDS MySQL에서 일반/느린 쿼리 로그 찍기</title>
      <link>/posts/logging-rds/</link>
      <pubDate>Wed, 03 Oct 2018 14:24:00 +0900</pubDate>
      <guid>/posts/logging-rds/</guid>
      <description>&lt;p&gt;RDS MySQL을 이용하면, 아래와 같이 CloudWatch에 일반/감사/느린 쿼리 로그를 찍도록 설정할 수 있다.&lt;/p&gt;&#xA;&lt;figure&gt;&lt;img src=&#34;/img/rds-logging-1.png&#34;&#xA;    alt=&#34;로그 찍기 설정(RDS 인스턴스 생성 시)&#34;&gt;&lt;figcaption&gt;&#xA;      &lt;p&gt;로그 찍기 설정(RDS 인스턴스 생성 시)&lt;/p&gt;&#xA;    &lt;/figcaption&gt;&#xA;&lt;/figure&gt;&#xA;&#xA;&lt;p&gt;그리고 RDS 콘솔에 들어가면 로그 파일을 볼 수 있는데, 일반 로그나 느린 쿼리 로그를 찾을 수 없었다. 그래서 CloudWatch Logs를 찾아봤지만, 역시 로그가 없었다.&lt;/p&gt;&#xA;&lt;figure&gt;&lt;img src=&#34;/img/rds-logging-2.png&#34;&#xA;    alt=&#34;로그 파일이 없다(-_-&amp;hellip;)&#34;&gt;&lt;figcaption&gt;&#xA;      &lt;p&gt;로그 파일이 없다(-_-&amp;hellip;)&lt;/p&gt;&#xA;    &lt;/figcaption&gt;&#xA;&lt;/figure&gt;&#xA;&#xA;&lt;p&gt;그 이유를 찾아 보니, 파라미터 그룹에 로그 관련 설정을 하지 않은 것이 원인이었다.&lt;/p&gt;&#xA;&lt;p&gt;다음과 같이 설정하면 된다.&lt;/p&gt;</description>
    </item>
    <item>
      <title>AWS Lambda에서 별칭(alias)으로 함수 버전 구분하기</title>
      <link>/posts/check-lambda-version/</link>
      <pubDate>Tue, 02 Oct 2018 23:16:00 +0900</pubDate>
      <guid>/posts/check-lambda-version/</guid>
      <description>&lt;p&gt;test라는 함수가 있고, dev, release라는 별칭(alias)이 존재한다고 하자. 그리고 모든 별칭은 동일한 버전을 가리킨다고 하자.&lt;/p&gt;&#xA;&lt;p&gt;이 경우 context 객체의 invoked_function_arn은 어떻게 달라지는지 보자. 테스트를 위해, 다음과 같이 파이썬으로 함수를 작성하였다.&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; json&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;lambda_handler&lt;/span&gt;(event, context): &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    print(context&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;invoked_function_arn)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Success&amp;#34;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;그리고 CloudWatch에 기록된 로그를 보자.&lt;/p&gt;&#xA;&lt;p&gt;dev인 경우&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;START RequestId: 2dce0b80-5fb4-11e8-b5b7-41e11422a67a Version: 1&#xA;arn:aws:lambda:ap-northeast-2:256724228018:function:test:dev&#xA;END RequestId: 2dce0b80-5fb4-11e8-b5b7-41e11422a67a&#xA;REPORT RequestId: 2dce0b80-5fb4-11e8-b5b7-41e11422a67a  Duration: 1.56 ms       Billed Duration: 100 ms         Memory Size: 128 MB     Max Memory Used: 22 MB&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;release인 경우&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
